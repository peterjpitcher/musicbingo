import { NextRequest, NextResponse } from "next/server";

import { formatEventDateDisplay } from "@/lib/eventDate";
import { parseSongListText } from "@/lib/parser";
import {
  getSpotifyWebConfig,
  refreshSpotifyAccessToken,
  spotifyApiRequest,
} from "@/lib/spotifyWeb";

export const runtime = "nodejs";

const COOKIE_REFRESH = "spotify_refresh_token";

function asString(value: FormDataEntryValue | null): string {
  return typeof value === "string" ? value : "";
}

function chunk<T>(items: T[], size: number): T[][] {
  const out: T[][] = [];
  for (let i = 0; i < items.length; i += size) out.push(items.slice(i, i + size));
  return out;
}

async function spotifyJson<T>(accessToken: string, url: string, init?: RequestInit): Promise<T> {
  const res = await spotifyApiRequest({ accessToken, url, init });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`Spotify API error ${res.status}${text ? `: ${text}` : ""}`);
  }
  return (await res.json()) as T;
}

async function mapWithConcurrency<T, R>(
  items: T[],
  concurrency: number,
  fn: (item: T, index: number) => Promise<R>
): Promise<R[]> {
  const results: R[] = new Array(items.length);
  let nextIndex = 0;

  async function worker() {
    while (true) {
      const index = nextIndex++;
      if (index >= items.length) return;
      results[index] = await fn(items[index] as T, index);
    }
  }

  const workers = Array.from({ length: Math.max(1, concurrency) }, () => worker());
  await Promise.all(workers);
  return results;
}

type SpotifyMeResponse = { id?: unknown };
type SpotifyPlaylistResponse = { id?: unknown; external_urls?: unknown };
type SpotifySearchResponse = { tracks?: { items?: Array<{ uri?: unknown }> } };

function getString(v: unknown): string | null {
  return typeof v === "string" && v.trim() ? v.trim() : null;
}

export async function POST(request: NextRequest) {
  const origin = new URL(request.url).origin;
  const secure = process.env.NODE_ENV === "production";

  const refreshToken = request.cookies.get(COOKIE_REFRESH)?.value ?? "";
  if (!refreshToken.trim()) {
    return new Response("Spotify is not connected. Click “Connect Spotify” and try again.", { status: 401 });
  }

  const form = await request.formData();

  const eventDateInput = asString(form.get("event_date")).trim();
  const eventDateDisplay = formatEventDateDisplay(eventDateInput);
  const playlistName = eventDateDisplay ? `Music Bingo - ${eventDateDisplay}` : "Music Bingo";

  let text = asString(form.get("songs"));
  const file = form.get("file");
  if (file && typeof file !== "string") {
    text = await file.text();
  }
  if (!text.trim()) {
    return new Response("Provide a song list (paste text or upload a .txt file).", { status: 400 });
  }

  let accessToken: string;
  let newRefreshToken: string | null = null;
  try {
    const cfg = getSpotifyWebConfig(origin);
    const refreshed = await refreshSpotifyAccessToken(cfg, refreshToken);
    accessToken = refreshed.accessToken;
    newRefreshToken = refreshed.refreshToken;
  } catch (err) {
    const msg = err instanceof Error ? err.message : "Failed to refresh Spotify token.";
    const res = new Response(`${msg}\n\nTry clicking “Connect Spotify” again.`, { status: 401 });
    return res;
  }

  try {
    const me = await spotifyJson<SpotifyMeResponse>(accessToken, "https://api.spotify.com/v1/me");
    const userId = getString(me.id);
    if (!userId) throw new Error("Spotify API error: missing user id");

    const playlist = await spotifyJson<SpotifyPlaylistResponse>(
      accessToken,
      `https://api.spotify.com/v1/users/${encodeURIComponent(userId)}/playlists`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: playlistName,
          public: false,
          description: "Generated by Music Bingo",
        }),
      }
    );

    const playlistId = getString(playlist.id);
    const playlistUrl = getString((playlist.external_urls as any)?.spotify);
    if (!playlistId) throw new Error("Spotify API error: missing playlist id");

    const parsed = parseSongListText(text);
    const songs = parsed.songs;
    if (!songs.length) {
      return new Response("No songs found in the input.", { status: 400 });
    }

    const results = await mapWithConcurrency(songs, 5, async (song) => {
      const q = `track:${song.title} artist:${song.artist}`;
      const params = new URLSearchParams({ q, type: "track", limit: "5" });
      const url = `https://api.spotify.com/v1/search?${params.toString()}`;
      const json = await spotifyJson<SpotifySearchResponse>(accessToken, url);
      const uri = getString(json.tracks?.items?.[0]?.uri);
      return uri ? { uri } : { notFound: { artist: song.artist, title: song.title } };
    });

    const trackUris = results.flatMap((r: any) => (r?.uri ? [r.uri as string] : []));
    const notFound = results.flatMap((r: any) => (r?.notFound ? [r.notFound as { artist: string; title: string }] : []));

    for (const uris of chunk(trackUris, 100)) {
      await spotifyJson(accessToken, `https://api.spotify.com/v1/playlists/${encodeURIComponent(playlistId)}/tracks`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ uris }),
      });
    }

    const body = {
      playlistId,
      playlistName,
      playlistUrl,
      totalSongs: songs.length,
      addedCount: trackUris.length,
      notFoundCount: notFound.length,
      notFound,
    };

    const res = NextResponse.json(body, { headers: { "Cache-Control": "no-store" } });
    if (newRefreshToken) {
      res.cookies.set({
        name: COOKIE_REFRESH,
        value: newRefreshToken,
        httpOnly: true,
        sameSite: "lax",
        secure,
        path: "/",
        maxAge: 60 * 60 * 24 * 30,
      });
    }
    return res;
  } catch (err: any) {
    const msg = err?.message ? String(err.message) : "Failed to create Spotify playlist.";
    return new Response(msg, { status: 500 });
  }
}

